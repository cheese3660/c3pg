<*
    This module contains an updated version of the lexer generator module, using the lexer and parser provided by C3Pg
*>
module c3pg::lexer_generator;
import c3pg::lexer_grammar::lexer;
import c3pg::lexer_grammar::parser;
import c3pg::runtime;
import c3pg::codegen;
import std::io::file;
import std::collections::map;
import std::collections::set;


fn void generate(String infile, String outfile)
{
    @pool()
    {
        String data = (String)file::load_temp(infile)!!;
        LexerLexer lexer = lexer::create_lexer_lexer(data,tmem,infile,runtime::std_err);
        LexerParser parser = parser::create_lexer_parser(&lexer,tmem,runtime::std_err);
        LexerNode* root = parser.parse_root()!!;
        LexerTransformer transformer = { infile, data, {}};
        root.visit(&transformer)!!;
        // io::printn(transformer.target);
        CodeGenerationContext cgc;
        transformer.target.generate(&cgc);
        File f = file::open(outfile,"w")!!;
        f.write((char[])cgc.cg.build())!!;
        f.flush()!!;
        f.close()!!;
    };
}

struct CodeGenerationContext
{
    Codegen cg;
    HashMap { String, usz } regexen;
    usz next_regex;
    String lexer_tname;
    String token_t_tname;
    String mode_tname;
}

struct TerminalGenerationContext
{
    bool needs_set_error;
    bool needs_push_mode;
    bool needs_pop_mode;
    bool needs_set_terminal;
    bool needs_drop;
}

fn void LexerDefinition.generate(&self, CodeGenerationContext *cgc)
{
    Codegen* cg = &cgc.cg;
    String tname = self.language_name.to_tname();
    String token_t_tname = cgc.token_t_tname = string::tformat("%sTokenT", tname);
    String token_tname = string::tformat("%sToken", tname);
    String mode_tname  = cgc.mode_tname = string::tformat("%sMode",  tname);
    String lexer_tname = cgc.lexer_tname = string::tformat("%sLexer", tname);
    String entry_tname = string::tformat("%sModeEntry", tname);
    HashMap { String, String } tokens;
    tokens.set("EOF", "");
    foreach (mode : self.modes)
    {
        mode.get_all_terminals(&tokens);
    }

    cg.@doc()
    {
        cg.line("[AUTOMATICALLY GENERATED BY C3PG]");
        cg.line("Lexer implementation for: %s", tname);
    };
    cg.line("module %s;", self.lexer_module);
    cg.line();
    cg.line("/* STANDARD IMPORTS */");
    cg.line();
    cg.line("import c3pg::runtime;");
    cg.line("import std::collections::list;");
    cg.line("import regex;");
    cg.line();
    cg.line("/* TOKEN TYPES */");
    cg.line();
    cg.@enum("%s : (String pattern)", token_t_tname)
    {
        tokens.@each(; String name, String pattern)
        {
            cg.line("%s = %s,", name, pattern.tescape());
        };
    };
    cg.line();
    cg.line("/* LEXER MODES */");
    cg.line();
    cg.@enum("%s : (bool errors_on_eof)", mode_tname)
    {
        foreach (mode : self.modes)
        {
            cg.line("%s = %s,", mode.mode_name, mode.is_error_on_eof);
        }
    };
    cg.line();
    cg.line("/* TOKEN TYPE */");
    cg.line();
    cg.@struct("%s", token_tname)
    {
        cg.line("%s type;", token_t_tname);
        cg.line("Span span;");
        cg.line("String view;");
    };
    cg.line();
    cg.line("/* MODE STACK ENTRY */");
    cg.line();
    cg.@struct("%s", entry_tname)
    {
        cg.line("%s mode;", mode_tname);
        cg.line("Span entered_at;");
    };
    cg.line();
    cg.line("/* LEXER CONTEXT */");
    cg.line();
    cg.@struct("%s", lexer_tname)
    {
        cg.line("String file_data;");
        cg.line("usz current_offset;");
        cg.line("String file;");
        cg.line("List { %s } mode_stack;", entry_tname);
        cg.line("%s current;", token_tname);
        cg.line("C3PgLogger logger;");
    };
    cg.line();
    cg.line("/* LEXER FUNCTIONS */");
    cg.line();
    cg.@fn("%s create_%s_lexer(String data, Allocator allocator, String file = `<input>`, C3PgLogger logger = null)", lexer_tname, self.language_name)
    {
        cg.line("%s result = {data, 0, file, {}, {}, logger};",lexer_tname);
        cg.line("result.mode_stack.init(allocator);");
        cg.line("result.enter_mode(DEFAULT, {0,1});");
        cg.line("return result;");
    };
    cg.line();
    cg.@fn("void %s.free(&self) @inline", lexer_tname)
    {
        cg.line("self.mode_stack.free();");
    };
    cg.line();
    cg.@fn("void %s.enter_mode(&self, %s mode, Span s) @inline", lexer_tname, mode_tname)
    {
        cg.line("self.mode_stack.push({mode, s});");
    };
    cg.line();
    cg.@fn("void %s.log_at(&self, Span s, String message) @inline @private", lexer_tname)
    {
        cg.line("if (self.logger != null) self.logger.log_error(s,message,self.file,self.file_data);");  
    };
    cg.line();
    cg.@fn("void %s.log_here(&self, String message) @inline @private", lexer_tname)
    {
        cg.line("self.log_at({self.current_offset, 1}, message);");
    };
    cg.line();
    cg.@fn("void? %s.advance(&self)", lexer_tname)
    {
        cg.@pool()
        {
            cg.@while("self.current_offset < self.file_data.len")
            {
                cg.@if("catch f = self.single_advance()")
                {
                    cg.@if("f == runtime::SINGLE_STEP_DROPPED")
                    {
                        cg.line("continue;");
                    };
                    cg.line("return f?;");
                };
                cg.line("return;");
            };
            cg.line("self.current = {EOF, {self.current_offset, 0}, ``};");
            cg.@if("self.mode_stack[^1].mode.errors_on_eof")
            {
                cg.line("self.log_at(self.mode_stack[^1].entered_at, string::tformat(`entered error mode '%%s' starting from here`,self.mode_stack[^1].mode));");
                cg.line("self.log_here(`and ended at EOF here.`);");
                cg.line("return runtime::ENDED_IN_ERROR_MODE?;");
            };
        };
    };
    cg.line();
    cg.@fn("void? %s.single_advance(&self) @private", lexer_tname)
    {
        cg.@switch("self.mode_stack[^1].mode")
        {
            foreach (mode : self.modes)
            {
                cg.@case("%s", mode.mode_name)
                {
                    cg.line("return self.advance_%s();", mode.mode_name.to_lower_tcopy());
                };
            }
        };
    };
    foreach (mode : self.modes)
    {
        mode.generate(cgc);
        cg.line();
    }
    cg.line("/* REGEXEN */");
    cg.line();
    cgc.regexen.@each(; String pattern, usz variable)
    {
        cg.line("RuntimeRegex regex%s; // /%s/", variable, pattern);
    };
    cg.line();
    cg.line("/* INITIALIZATION OF REGEXEN */");
    cg.line();
    cg.@fn("void init_regexen() @private @init")
    {
        cgc.regexen.@each(; String pattern, usz variable)
        {
            cg.line("regex%s = regex::make_runtime_regex(`%s`,NONE,mem)!!;", variable, pattern);
        };
    };
}

fn void LexerMode.get_all_terminals(&self, HashMap { String, String } *target)
{
    foreach (child : self.terminals)
    {
        // if (child.type == NORMAL) target.add(child.name);
        if (child.type == NORMAL)
        {
            if (try v = target.get(child.name))
            {
                if (v != child.pattern || child.is_pattern_regex)
                {
                    target.set(child.name, "");
                }
            }
            else if (child.is_pattern_regex)
            {
                target.set(child.name, "");
            }
            else
            {
                target.set(child.name, child.pattern);
            }
        }
    }
}

fn void LexerMode.generate(&self, CodeGenerationContext *cgc)
{
    Codegen* cg = &cgc.cg;
    bool needs_is_error;
    bool all_is_error=true;
    bool needs_is_drop;
    bool all_is_drop=true;
    bool needs_is_pop;
    bool all_is_pop=true;
    bool needs_switches_modes;
    bool all_is_switches=true;
    bool needs_type;
    foreach (terminal : self.terminals)
    {
        if (terminal.is_error())
        {
            needs_is_error = true;
        }
        else
        {
            all_is_error = false;
        }

        if (terminal.is_drop())
        {
            needs_is_drop = true;
        }
        else
        {
            all_is_drop = false;
        }

        if (!terminal.is_error() && !terminal.is_drop()) 
        {
            needs_type = true;
        }

        if (terminal.is_pop())
        {
            needs_is_pop = true;
        }
        else
        {
            all_is_pop = false;
        }

        if (terminal.is_push())
        {
            needs_switches_modes = true;
        }
        else
        {
            all_is_switches = false;
        }
    }

    cg.@fn("void? %s.advance_%s(&self)", cgc.lexer_tname, self.mode_name.to_lower_tcopy())
    {
        cg.line("usz offset = self.current_offset;");
        cg.line("String rest = self.file_data[offset..];");
        cg.line("usz length;");
        if (needs_type) cg.line("%s type;", cgc.token_t_tname);
        if (needs_is_error && !all_is_error) cg.line("bool is_error;");
        if (needs_is_error) cg.line("String error;");
        if (needs_is_drop && !all_is_drop) cg.line("bool is_drop;");
        if (needs_is_pop && !all_is_pop) cg.line("bool is_pop;");
        if (needs_switches_modes && !all_is_switches) cg.line("bool switches_modes;");
        if (needs_switches_modes) cg.line("%s next_mode;", cgc.mode_tname);
        cg.line();
        foreach (terminal : self.terminals)
        {
            terminal.generate(cgc, {needs_is_error && !all_is_error, needs_switches_modes && !all_is_switches, needs_is_pop && !all_is_pop, needs_type, needs_is_drop && !all_is_drop});
            cg.line();
        }
        cg.line("self.current_offset += length;");
        if (needs_switches_modes)
        {
            if (all_is_switches)
            {
                cg.line("self.enter_mode(next_mode, {offset, length});");
            }
            else
            {
                cg.@if("switches_modes")
                {
                    cg.line("self.enter_mode(next_mode, {offset, length});");
                };
            }
        }

        if (needs_is_pop)
        {
            if (all_is_pop)
            {
                cg.line("self.mode_stack.pop()!!;");
                cg.@if("self.mode_stack.len() == 0")
                {
                    cg.line("self.log_at({offset, length}, `token caused mode stack to become empty`);");
                    cg.line("return runtime::MODE_STACK_CLEARED?;");
                };
            }
            else
            {
                cg.@if("is_pop")
                {
                    cg.line("self.mode_stack.pop()!!;");
                    cg.@if("self.mode_stack.len() == 0")
                    {
                        cg.line("self.log_at({offset, length}, `token caused mode stack to become empty`);");
                        cg.line("return runtime::MODE_STACK_CLEARED?;");
                    };
                };
            }
        }

        if (needs_is_error)
        {
            if (all_is_error)
            {
                cg.line("self.log_at({offset, length},error.len == 0 ? `error terminal lexed` : error);");
                cg.line("return runtime::ERROR_TOKEN?;");
            }
            else
            {
                cg.@if("is_error")
                {
                    cg.line("self.log_at({offset, length},error.len == 0 ? `error terminal lexed` : error);");
                    cg.line("return runtime::ERROR_TOKEN?;");
                };
                if (needs_type || (needs_is_drop && !all_is_drop) || (needs_switches_modes && !all_is_switches) || (needs_is_pop && !all_is_pop)) cg.line();
            }
        }
        if (needs_is_drop)
        {
            if (all_is_drop)
            {
                cg.line("return runtime::SINGLE_STEP_DROPPED?;");
            }
            else
            {
                cg.@if("is_drop")
                {
                    cg.line("return runtime::SINGLE_STEP_DROPPED?;");
                };
            }
        }
        if (needs_type)
        {
            cg.line("self.current = {type, {offset,length}, rest[:length]};");
        }
    };
}

fn bool LexerTerminal.is_drop(&self) => self.type == DROP;
fn bool LexerTerminal.is_error(&self) => self.type == ERROR;
fn bool LexerTerminal.is_push(&self) => self.push_mode.len > 0 && self.push_mode != "POP";
fn bool LexerTerminal.is_pop(&self) => self.push_mode == "POP";

fn void LexerTerminal.generate(&self, CodeGenerationContext *cgc, TerminalGenerationContext ctx)
{
    Codegen* cg = &cgc.cg;
    String length;
    String condition;
    if (self.is_pattern_regex)
    {
        if (try regex = cgc.regexen.get(self.pattern))
        {
            condition = string::tformat("try match = regex%d.match_in_view(rest, 0, tmem) && match.end_offset() > length", regex);
        }
        else
        {
            condition = string::tformat("try match = regex%d.match_in_view(rest, 0, tmem) && match.end_offset() > length", cgc.next_regex);
            cgc.regexen.set(self.pattern, cgc.next_regex++);
        }
        length = "length = match.end_offset();";
    }
    else
    {
        condition = string::tformat("%s > length && rest.starts_with(%s)", self.pattern.len, self.pattern.tescape());
        length = string::tformat("length = %s;", self.pattern.len);
    }

    cg.@if("%s", condition)
    {
        cg.line("%s", length);

        if (ctx.needs_pop_mode)
        {
            if (self.is_pop())
            {
                cg.line("is_pop = true;");
            }
            else
            {
                cg.line("is_pop = false;");
            }
        };

        if (ctx.needs_push_mode)
        {
            if (self.is_push())
            {
                cg.line("switches_modes = true;");
            }
            else
            {
                cg.line("switches_modes = false;");
            }
        }

        if (self.is_push())
        {
            cg.line("next_mode = %s;", self.push_mode);
        }

        if (self.type == ERROR)
        {
            cg.line("error = %s;", self.error.tescape());
        }

        if (ctx.needs_set_error)
        {
            if (self.type == ERROR)
            {
                cg.line("is_error = true;");
                return;
            }
            else
            {
                cg.line("is_error = false;");
            }
        }

        if (ctx.needs_drop)
        {
            if (self.type == DROP)
            {
                cg.line("is_drop = true;");
            }
            else
            {
                cg.line("is_drop = false;");
            }
        }

        if (ctx.needs_set_terminal)
        {
            if (self.type == NORMAL)
            {
                cg.line("type = %s;", self.name);
            }
        }
    };
}