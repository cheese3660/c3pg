<*
	[AUTOMATICALLY GENERATED BY C3PG]
	Lexer implementation for: Parser
*>
module c3pg::parser_grammar::lexer;

/* STANDARD IMPORTS */

import c3pg::runtime;
import std::collections::list;
import regex;

/* TOKEN TYPES */

enum ParserTokenT : (String pattern)
{
	ANY_AMOUNT = "*",
	OPEN_NAME = "{",
	PARSER_IDENTIFIER = "parser",
	EOF = "",
	DEFINE = ":=",
	INFORMATION_SEPARATOR = ":",
	OPEN_GROUP = "(",
	INFORMATION_NAMESPACE = "::",
	END_INFORMATION = "}",
	TERMINAL = "",
	SEMICOLON = ";",
	COMMA = ",",
	INFORMATION_IDENT = "",
	ATTRIBUTE = "",
	CLOSE_NAME = "}",
	ALTERNATIVE = "|",
	CLOSE_GROUP = ")",
	BEGIN_INFORMATION = "{",
	NONTERMINAL = "",
	OPTIONAL = "?",
	AT_LEAST_ONE = "+",
}

/* LEXER MODES */

enum ParserMode : (bool errors_on_eof)
{
	DEFAULT = false,
	INFORMATION = true,
	BODY = false,
	COMMENT = false,
}

/* TOKEN TYPE */

struct ParserToken
{
	ParserTokenT type;
	Span span;
	String view;
}

/* MODE STACK ENTRY */

struct ParserModeEntry
{
	ParserMode mode;
	Span entered_at;
}

/* LEXER CONTEXT */

struct ParserLexer
{
	String file_data;
	usz current_offset;
	String file;
	List { ParserModeEntry } mode_stack;
	ParserToken current;
	C3PgLogger logger;
}

/* LEXER FUNCTIONS */

fn ParserLexer create_parser_lexer(String data, Allocator allocator, String file = "<input>", C3PgLogger logger = null)
{
	ParserLexer result = {data, 0, file, {}, {}, logger};
	result.mode_stack.init(allocator);
	result.enter_mode(DEFAULT);
	return result;
}

fn void ParserLexer.free(&self) @inline => self.mode_stack.free();

fn void ParserLexer.enter_mode(&self, ParserMode mode, usz length=1) @inline => self.mode_stack.push({mode, {self.current_offset, length}});

fn void ParserLexer.eat(&self, usz amount) @private
{
	self.current_offset += amount;
}

fn void ParserLexer.log_at(&self, Span s, String message) @inline @private
{
	if (self.logger != null) self.logger.log_error(s,message,self.file,self.file_data);
}

fn void ParserLexer.log_here(&self, String message) @inline @private => self.log_at({self.current_offset, 1}, message);

fn void? ParserLexer.advance(&self)
{
	@pool()
	{
		while (self.current_offset < self.file_data.len)
		{
			if (catch f = self.single_advance())
			{
				if (f == runtime::SINGLE_STEP_DROPPED) continue;
				return f?;
			}
			return;
		}
		if (self.mode_stack[^1].mode.errors_on_eof)
		{
			self.log_at(self.mode_stack[^1].entered_at, string::tformat(`entered error mode '%s' starting from here`,self.mode_stack[^1].mode));
			return runtime::ENDED_IN_ERROR_MODE?;
		}
		self.current = {EOF, {self.current_offset, 0}, ``};
	};
}

fn void? ParserLexer.single_advance(&self) @private
{
	switch (self.mode_stack[^1].mode)
	{
		case DEFAULT:
			return self.advance_default();
		case INFORMATION:
			return self.advance_information();
		case BODY:
			return self.advance_body();
		case COMMENT:
			return self.advance_comment();
	}
}

fn void? ParserLexer.advance_default(&self)
{
	String rest = self.file_data[self.current_offset..];
	ParserTokenT type;
	usz length;
	bool is_error;
	bool is_drop;
	bool is_pop;
	bool switches_modes;
	ParserMode next_mode;
	if (6 > length && rest.starts_with("parser"))
	{
		length = 6;
		is_error = false;
		is_drop = false;
		type = PARSER_IDENTIFIER;
		is_pop = false;
		switches_modes = false;
	}
	if (1 > length && rest.starts_with("{"))
	{
		length = 1;
		is_error = false;
		is_drop = false;
		type = BEGIN_INFORMATION;
		is_pop = false;
		switches_modes = true;
		next_mode = INFORMATION;
	}
	if (1 > length && rest.starts_with("#"))
	{
		length = 1;
		is_error = false;
		is_drop = true;
		is_pop = false;
		switches_modes = true;
		next_mode = COMMENT;
	}
	if (try match = regex0.match_in_view(rest, 0, tmem) && match.end_offset() > length) // /\s+/
	{
		length = match.end_offset();
		is_error = false;
		is_drop = true;
		is_pop = false;
		switches_modes = false;
	}
	if (length == 0)
	{
		self.log_here(string::tformat(`Unexpected character '%c'!`, rest[0]));
		return runtime::UNEXPECTED_CHARACTER?;
	}
	if (is_error)
	{
		self.log_here(string::tformat(`error terminal %s lexed`, rest[:length].tescape()));
		return runtime::ERROR_TOKEN?;
	}
	if (switches_modes) self.enter_mode(next_mode, length);
	if (is_pop)
	{
		self.mode_stack.pop()!!;
		if (self.mode_stack.len() == 0)
		{
			self.log_here(`token at this position caused the mode stack to be cleared`);
			return runtime::MODE_STACK_CLEARED?;
		}
	}
	String token = rest[:length];
	Span token_span = {self.current_offset, length};
	self.eat(length);
	if (is_drop)
	{
		return runtime::SINGLE_STEP_DROPPED?;
	}
	self.current = {type, token_span, token};
}

fn void? ParserLexer.advance_information(&self)
{
	String rest = self.file_data[self.current_offset..];
	ParserTokenT type;
	usz length;
	bool is_error;
	bool is_drop;
	bool is_pop;
	bool switches_modes;
	ParserMode next_mode;
	if (try match = regex1.match_in_view(rest, 0, tmem) && match.end_offset() > length) // /[a-z][a-zA-Z0-9_]*/
	{
		length = match.end_offset();
		is_error = false;
		is_drop = false;
		type = INFORMATION_IDENT;
		is_pop = false;
		switches_modes = false;
	}
	if (1 > length && rest.starts_with(":"))
	{
		length = 1;
		is_error = false;
		is_drop = false;
		type = INFORMATION_SEPARATOR;
		is_pop = false;
		switches_modes = false;
	}
	if (2 > length && rest.starts_with("::"))
	{
		length = 2;
		is_error = false;
		is_drop = false;
		type = INFORMATION_NAMESPACE;
		is_pop = false;
		switches_modes = false;
	}
	if (1 > length && rest.starts_with("}"))
	{
		length = 1;
		is_error = false;
		is_drop = false;
		type = END_INFORMATION;
		is_pop = false;
		switches_modes = true;
		next_mode = BODY;
	}
	if (1 > length && rest.starts_with("#"))
	{
		length = 1;
		is_error = false;
		is_drop = true;
		is_pop = false;
		switches_modes = true;
		next_mode = COMMENT;
	}
	if (try match = regex0.match_in_view(rest, 0, tmem) && match.end_offset() > length) // /\s+/
	{
		length = match.end_offset();
		is_error = false;
		is_drop = true;
		is_pop = false;
		switches_modes = false;
	}
	if (length == 0)
	{
		self.log_here(string::tformat(`Unexpected character '%c'!`, rest[0]));
		return runtime::UNEXPECTED_CHARACTER?;
	}
	if (is_error)
	{
		self.log_here(string::tformat(`error terminal %s lexed`, rest[:length].tescape()));
		return runtime::ERROR_TOKEN?;
	}
	if (switches_modes) self.enter_mode(next_mode, length);
	if (is_pop)
	{
		self.mode_stack.pop()!!;
		if (self.mode_stack.len() == 0)
		{
			self.log_here(`token at this position caused the mode stack to be cleared`);
			return runtime::MODE_STACK_CLEARED?;
		}
	}
	String token = rest[:length];
	Span token_span = {self.current_offset, length};
	self.eat(length);
	if (is_drop)
	{
		return runtime::SINGLE_STEP_DROPPED?;
	}
	self.current = {type, token_span, token};
}

fn void? ParserLexer.advance_body(&self)
{
	String rest = self.file_data[self.current_offset..];
	ParserTokenT type;
	usz length;
	bool is_error;
	bool is_drop;
	bool is_pop;
	bool switches_modes;
	ParserMode next_mode;
	if (try match = regex2.match_in_view(rest, 0, tmem) && match.end_offset() > length) // /[A-Z][A-Z0-9_]*/
	{
		length = match.end_offset();
		is_error = false;
		is_drop = false;
		type = TERMINAL;
		is_pop = false;
		switches_modes = false;
	}
	if (try match = regex3.match_in_view(rest, 0, tmem) && match.end_offset() > length) // /[a-z][a-z0-9_]*/
	{
		length = match.end_offset();
		is_error = false;
		is_drop = false;
		type = NONTERMINAL;
		is_pop = false;
		switches_modes = false;
	}
	if (try match = regex4.match_in_view(rest, 0, tmem) && match.end_offset() > length) // /@[a-z_]+/
	{
		length = match.end_offset();
		is_error = false;
		is_drop = false;
		type = ATTRIBUTE;
		is_pop = false;
		switches_modes = false;
	}
	if (2 > length && rest.starts_with(":="))
	{
		length = 2;
		is_error = false;
		is_drop = false;
		type = DEFINE;
		is_pop = false;
		switches_modes = false;
	}
	if (1 > length && rest.starts_with(";"))
	{
		length = 1;
		is_error = false;
		is_drop = false;
		type = SEMICOLON;
		is_pop = false;
		switches_modes = false;
	}
	if (1 > length && rest.starts_with("|"))
	{
		length = 1;
		is_error = false;
		is_drop = false;
		type = ALTERNATIVE;
		is_pop = false;
		switches_modes = false;
	}
	if (1 > length && rest.starts_with("{"))
	{
		length = 1;
		is_error = false;
		is_drop = false;
		type = OPEN_NAME;
		is_pop = false;
		switches_modes = false;
	}
	if (1 > length && rest.starts_with("}"))
	{
		length = 1;
		is_error = false;
		is_drop = false;
		type = CLOSE_NAME;
		is_pop = false;
		switches_modes = false;
	}
	if (1 > length && rest.starts_with("("))
	{
		length = 1;
		is_error = false;
		is_drop = false;
		type = OPEN_GROUP;
		is_pop = false;
		switches_modes = false;
	}
	if (1 > length && rest.starts_with(")"))
	{
		length = 1;
		is_error = false;
		is_drop = false;
		type = CLOSE_GROUP;
		is_pop = false;
		switches_modes = false;
	}
	if (1 > length && rest.starts_with("?"))
	{
		length = 1;
		is_error = false;
		is_drop = false;
		type = OPTIONAL;
		is_pop = false;
		switches_modes = false;
	}
	if (1 > length && rest.starts_with("+"))
	{
		length = 1;
		is_error = false;
		is_drop = false;
		type = AT_LEAST_ONE;
		is_pop = false;
		switches_modes = false;
	}
	if (1 > length && rest.starts_with("*"))
	{
		length = 1;
		is_error = false;
		is_drop = false;
		type = ANY_AMOUNT;
		is_pop = false;
		switches_modes = false;
	}
	if (1 > length && rest.starts_with(","))
	{
		length = 1;
		is_error = false;
		is_drop = false;
		type = COMMA;
		is_pop = false;
		switches_modes = false;
	}
	if (1 > length && rest.starts_with("#"))
	{
		length = 1;
		is_error = false;
		is_drop = true;
		is_pop = false;
		switches_modes = true;
		next_mode = COMMENT;
	}
	if (try match = regex0.match_in_view(rest, 0, tmem) && match.end_offset() > length) // /\s+/
	{
		length = match.end_offset();
		is_error = false;
		is_drop = true;
		is_pop = false;
		switches_modes = false;
	}
	if (length == 0)
	{
		self.log_here(string::tformat(`Unexpected character '%c'!`, rest[0]));
		return runtime::UNEXPECTED_CHARACTER?;
	}
	if (is_error)
	{
		self.log_here(string::tformat(`error terminal %s lexed`, rest[:length].tescape()));
		return runtime::ERROR_TOKEN?;
	}
	if (switches_modes) self.enter_mode(next_mode, length);
	if (is_pop)
	{
		self.mode_stack.pop()!!;
		if (self.mode_stack.len() == 0)
		{
			self.log_here(`token at this position caused the mode stack to be cleared`);
			return runtime::MODE_STACK_CLEARED?;
		}
	}
	String token = rest[:length];
	Span token_span = {self.current_offset, length};
	self.eat(length);
	if (is_drop)
	{
		return runtime::SINGLE_STEP_DROPPED?;
	}
	self.current = {type, token_span, token};
}

fn void? ParserLexer.advance_comment(&self)
{
	String rest = self.file_data[self.current_offset..];
	ParserTokenT type;
	usz length;
	bool is_error;
	bool is_drop;
	bool is_pop;
	bool switches_modes;
	ParserMode next_mode;
	if (1 > length && rest.starts_with("\n"))
	{
		length = 1;
		is_error = false;
		is_drop = true;
		is_pop = true;
		switches_modes = false;
	}
	if (try match = regex5.match_in_view(rest, 0, tmem) && match.end_offset() > length) // /.+/
	{
		length = match.end_offset();
		is_error = false;
		is_drop = true;
		is_pop = false;
		switches_modes = false;
	}
	if (length == 0)
	{
		self.log_here(string::tformat(`Unexpected character '%c'!`, rest[0]));
		return runtime::UNEXPECTED_CHARACTER?;
	}
	if (is_error)
	{
		self.log_here(string::tformat(`error terminal %s lexed`, rest[:length].tescape()));
		return runtime::ERROR_TOKEN?;
	}
	if (switches_modes) self.enter_mode(next_mode, length);
	if (is_pop)
	{
		self.mode_stack.pop()!!;
		if (self.mode_stack.len() == 0)
		{
			self.log_here(`token at this position caused the mode stack to be cleared`);
			return runtime::MODE_STACK_CLEARED?;
		}
	}
	String token = rest[:length];
	Span token_span = {self.current_offset, length};
	self.eat(length);
	if (is_drop)
	{
		return runtime::SINGLE_STEP_DROPPED?;
	}
	self.current = {type, token_span, token};
}

/* REGEXEN */

RuntimeRegex regex0; // /\s+/
RuntimeRegex regex4; // /@[a-z_]+/
RuntimeRegex regex1; // /[a-z][a-zA-Z0-9_]*/
RuntimeRegex regex2; // /[A-Z][A-Z0-9_]*/
RuntimeRegex regex5; // /.+/
RuntimeRegex regex3; // /[a-z][a-z0-9_]*/

/* INITIALIZATION OF REGEXEN */

fn void init_regexen() @private @init
{
	regex0 = regex::make_runtime_regex(`\s+`,NONE,mem)!!;
	regex4 = regex::make_runtime_regex(`@[a-z_]+`,NONE,mem)!!;
	regex1 = regex::make_runtime_regex(`[a-z][a-zA-Z0-9_]*`,NONE,mem)!!;
	regex2 = regex::make_runtime_regex(`[A-Z][A-Z0-9_]*`,NONE,mem)!!;
	regex5 = regex::make_runtime_regex(`.+`,NONE,mem)!!;
	regex3 = regex::make_runtime_regex(`[a-z][a-z0-9_]*`,NONE,mem)!!;
}
