<*
	[AUTOMATICALLY GENERATED BY C3PG]
	Lexer implementation for: Lexer
*>
module c3pg::lexer_grammar::lexer;

/* STANDARD IMPORTS */

import c3pg::runtime;
import std::collections::list;
import regex;

/* TOKEN TYPES */
enum LexerTokenT : (String pattern)
{
	STRING_BEGIN = "'",
	LPAREN = "(",
	ERROR = "@error",
	RPAREN = ")",
	DEFINITION = ":=",
	MODE_BEGIN = ":",
	REGEX_END = "/",
	EOF = "",
	INFORMATION_SEPARATOR = ":",
	LEXER_IDENTIFIER = "lexer",
	INFORMATION_NAMESPACE = "::",
	REGEX_BEGIN = "/",
	END_INFORMATION = "}",
	INFORMATION_IDENT = "",
	MODE = "mode",
	CHARACTER = "",
	STRING_END = "'",
	BEGIN_INFORMATION = "{",
	MODE_ERRORS = "!",
	IDENT = "",
	DROP = "@drop",
}

/* LEXER MODES */

enum LexerMode : (bool errors_on_eof)
{
	DEFAULT = false,
	INFORMATION = true,
	BODY = false,
	REGEX = true,
	STRING = true,
	ESCAPE = true,
	COMMENT = false,
}

/* TOKEN TYPE */

struct LexerToken
{
	LexerTokenT type;
	Span span;
	String view;
}

/* MODE STACK ENTRY */

struct LexerModeEntry
{
	LexerMode mode;
	Span entered_at;
}

/* LEXER CONTEXT */

struct LexerLexer
{
	String file_data;
	usz current_offset;
	String file;
	List { LexerModeEntry } mode_stack;
	LexerToken current;
	C3PgLogger logger;
}

/* LEXER FUNCTIONS */

fn LexerLexer create_lexer_lexer(String data, Allocator allocator, String file = `<input>`, C3PgLogger logger = null)
{
	LexerLexer result = {data, 0, file, {}, {}, logger};
	result.mode_stack.init(allocator);
	result.enter_mode(DEFAULT, {0,1});
	return result;
}

fn void LexerLexer.free(&self) @inline
{
	self.mode_stack.free();
}

fn void LexerLexer.enter_mode(&self, LexerMode mode, Span s) @inline
{
	self.mode_stack.push({mode, s});
}

fn void LexerLexer.log_at(&self, Span s, String message) @inline @private
{
	if (self.logger != null) self.logger.log_error(s,message,self.file,self.file_data);
}

fn void LexerLexer.log_here(&self, String message) @inline @private
{
	self.log_at({self.current_offset, 1}, message);
}

fn void? LexerLexer.advance(&self)
{
	@pool()
	{
		while (self.current_offset < self.file_data.len)
		{
			if (catch f = self.single_advance())
			{
				if (f == runtime::SINGLE_STEP_DROPPED)
				{
					continue;
				}
				return f?;
			}
			return;
		}
		self.current = {EOF, {self.current_offset, 0}, ``};
		if (self.mode_stack[^1].mode.errors_on_eof)
		{
			self.log_at(self.mode_stack[^1].entered_at, string::tformat(`entered error mode '%s' starting from here`,self.mode_stack[^1].mode));
			self.log_here(`and ended at EOF here.`);
			return runtime::ENDED_IN_ERROR_MODE?;
		}
	};
}

fn void? LexerLexer.single_advance(&self) @private
{
	switch (self.mode_stack[^1].mode)
	{
		case DEFAULT:
			return self.advance_default();
		case INFORMATION:
			return self.advance_information();
		case BODY:
			return self.advance_body();
		case REGEX:
			return self.advance_regex();
		case STRING:
			return self.advance_string();
		case ESCAPE:
			return self.advance_escape();
		case COMMENT:
			return self.advance_comment();
	}
}

fn void? LexerLexer.advance_default(&self)
{
	usz offset = self.current_offset;
	String rest = self.file_data[offset..];
	usz length;
	LexerTokenT type;
	bool is_drop;
	bool switches_modes;
	LexerMode next_mode;

	if (5 > length && rest.starts_with("lexer"))
	{
		length = 5;
		switches_modes = false;
		type = LEXER_IDENTIFIER;
	}

	if (1 > length && rest.starts_with("{"))
	{
		length = 1;
		switches_modes = true;
		next_mode = INFORMATION;
		type = BEGIN_INFORMATION;
	}

	if (1 > length && rest.starts_with("#"))
	{
		length = 1;
		switches_modes = true;
		next_mode = COMMENT;
		is_drop = true;
	}
	if (try match = regex0.match_in_view(rest, 0, tmem) && match.end_offset() > length) // /\s+/
	{
		length = match.end_offset();
		switches_modes = false;
		is_drop = true;
	}
	self.current_offset += length;
	if (length == 0)
	{
		self.log_here(string::tformat(`Unexpected character '%s'!`, rest[0:1].tescape(true)));
		self.current_offset += 1;
		return runtime::UNEXPECTED_CHARACTER?;
	}

	if (switches_modes)
	{
		self.enter_mode(next_mode, {offset, length});
	}
	if (is_drop)
	{
		return runtime::SINGLE_STEP_DROPPED?;
	}
	self.current = {type, {offset,length}, rest[:length]};
}

fn void? LexerLexer.advance_information(&self)
{
	usz offset = self.current_offset;
	String rest = self.file_data[offset..];
	usz length;
	LexerTokenT type;
	bool is_drop;
	bool switches_modes;
	LexerMode next_mode;

	if (try match = regex1.match_in_view(rest, 0, tmem) && match.end_offset() > length) // /[a-z][a-zA-Z0-9_]*/
	{
		length = match.end_offset();
		switches_modes = false;
		type = INFORMATION_IDENT;
	}

	if (1 > length && rest.starts_with(":"))
	{
		length = 1;
		switches_modes = false;
		type = INFORMATION_SEPARATOR;
	}

	if (2 > length && rest.starts_with("::"))
	{
		length = 2;
		switches_modes = false;
		type = INFORMATION_NAMESPACE;
	}

	if (1 > length && rest.starts_with("}"))
	{
		length = 1;
		switches_modes = true;
		next_mode = BODY;
		type = END_INFORMATION;
	}

	if (1 > length && rest.starts_with("#"))
	{
		length = 1;
		switches_modes = true;
		next_mode = COMMENT;
		is_drop = true;
	}
	if (try match = regex0.match_in_view(rest, 0, tmem) && match.end_offset() > length) // /\s+/
	{
		length = match.end_offset();
		switches_modes = false;
		is_drop = true;
	}
	self.current_offset += length;
	if (length == 0)
	{
		self.log_here(string::tformat(`Unexpected character '%s'!`, rest[0:1].tescape(true)));
		self.current_offset += 1;
		return runtime::UNEXPECTED_CHARACTER?;
	}

	if (switches_modes)
	{
		self.enter_mode(next_mode, {offset, length});
	}
	if (is_drop)
	{
		return runtime::SINGLE_STEP_DROPPED?;
	}
	self.current = {type, {offset,length}, rest[:length]};
}

fn void? LexerLexer.advance_body(&self)
{
	usz offset = self.current_offset;
	String rest = self.file_data[offset..];
	usz length;
	LexerTokenT type;
	bool is_drop;
	bool switches_modes;
	LexerMode next_mode;

	if (try match = regex2.match_in_view(rest, 0, tmem) && match.end_offset() > length) // /[A-Z][A-Z0-9_]*/
	{
		length = match.end_offset();
		switches_modes = false;
		type = IDENT;
	}

	if (2 > length && rest.starts_with(":="))
	{
		length = 2;
		switches_modes = false;
		type = DEFINITION;
	}

	if (4 > length && rest.starts_with("mode"))
	{
		length = 4;
		switches_modes = false;
		type = MODE;
	}

	if (1 > length && rest.starts_with(":"))
	{
		length = 1;
		switches_modes = false;
		type = MODE_BEGIN;
	}

	if (1 > length && rest.starts_with("!"))
	{
		length = 1;
		switches_modes = false;
		type = MODE_ERRORS;
	}

	if (5 > length && rest.starts_with("@drop"))
	{
		length = 5;
		switches_modes = false;
		type = DROP;
	}

	if (6 > length && rest.starts_with("@error"))
	{
		length = 6;
		switches_modes = false;
		type = ERROR;
	}

	if (1 > length && rest.starts_with("("))
	{
		length = 1;
		switches_modes = false;
		type = LPAREN;
	}

	if (1 > length && rest.starts_with(")"))
	{
		length = 1;
		switches_modes = false;
		type = RPAREN;
	}

	if (1 > length && rest.starts_with("/"))
	{
		length = 1;
		switches_modes = true;
		next_mode = REGEX;
		type = REGEX_BEGIN;
	}

	if (1 > length && rest.starts_with("'"))
	{
		length = 1;
		switches_modes = true;
		next_mode = STRING;
		type = STRING_BEGIN;
	}

	if (1 > length && rest.starts_with("#"))
	{
		length = 1;
		switches_modes = true;
		next_mode = COMMENT;
		is_drop = true;
	}
	if (try match = regex0.match_in_view(rest, 0, tmem) && match.end_offset() > length) // /\s+/
	{
		length = match.end_offset();
		switches_modes = false;
		is_drop = true;
	}
	self.current_offset += length;
	if (length == 0)
	{
		self.log_here(string::tformat(`Unexpected character '%s'!`, rest[0:1].tescape(true)));
		self.current_offset += 1;
		return runtime::UNEXPECTED_CHARACTER?;
	}

	if (switches_modes)
	{
		self.enter_mode(next_mode, {offset, length});
	}
	if (is_drop)
	{
		return runtime::SINGLE_STEP_DROPPED?;
	}
	self.current = {type, {offset,length}, rest[:length]};
}

fn void? LexerLexer.advance_regex(&self)
{
	usz offset = self.current_offset;
	String rest = self.file_data[offset..];
	usz length;
	LexerTokenT type;
	bool is_pop;
	bool switches_modes;
	LexerMode next_mode;

	if (1 > length && rest.starts_with("\\"))
	{
		length = 1;
		is_pop = false;
		switches_modes = true;
		next_mode = ESCAPE;
		type = CHARACTER;
	}

	if (1 > length && rest.starts_with("/"))
	{
		length = 1;
		is_pop = true;
		type = REGEX_END;
	}

	if (try match = regex3.match_in_view(rest, 0, tmem) && match.end_offset() > length) // /./
	{
		length = match.end_offset();
		is_pop = false;
		switches_modes = false;
		type = CHARACTER;
	}

	self.current_offset += length;
	if (length == 0)
	{
		self.log_here(string::tformat(`Unexpected character '%s'!`, rest[0:1].tescape(true)));
		self.current_offset += 1;
		return runtime::UNEXPECTED_CHARACTER?;
	}

	if (is_pop)
	{
		self.mode_stack.pop()!!;
		if (self.mode_stack.len() == 0)
		{
			self.log_at({offset, length}, `token caused mode stack to become empty`);
			return runtime::MODE_STACK_CLEARED?;
		}
	}
	if (switches_modes)
	{
		self.enter_mode(next_mode, {offset, length});
	}
	self.current = {type, {offset,length}, rest[:length]};
}

fn void? LexerLexer.advance_string(&self)
{
	usz offset = self.current_offset;
	String rest = self.file_data[offset..];
	usz length;
	LexerTokenT type;
	bool is_pop;
	bool switches_modes;
	LexerMode next_mode;

	if (1 > length && rest.starts_with("\\"))
	{
		length = 1;
		is_pop = false;
		switches_modes = true;
		next_mode = ESCAPE;
		type = CHARACTER;
	}

	if (1 > length && rest.starts_with("'"))
	{
		length = 1;
		is_pop = true;
		type = STRING_END;
	}

	if (try match = regex3.match_in_view(rest, 0, tmem) && match.end_offset() > length) // /./
	{
		length = match.end_offset();
		is_pop = false;
		switches_modes = false;
		type = CHARACTER;
	}

	self.current_offset += length;
	if (length == 0)
	{
		self.log_here(string::tformat(`Unexpected character '%s'!`, rest[0:1].tescape(true)));
		self.current_offset += 1;
		return runtime::UNEXPECTED_CHARACTER?;
	}

	if (is_pop)
	{
		self.mode_stack.pop()!!;
		if (self.mode_stack.len() == 0)
		{
			self.log_at({offset, length}, `token caused mode stack to become empty`);
			return runtime::MODE_STACK_CLEARED?;
		}
	}
	if (switches_modes)
	{
		self.enter_mode(next_mode, {offset, length});
	}
	self.current = {type, {offset,length}, rest[:length]};
}

fn void? LexerLexer.advance_escape(&self)
{
	usz offset = self.current_offset;
	String rest = self.file_data[offset..];
	usz length;
	LexerTokenT type;

	if (try match = regex3.match_in_view(rest, 0, tmem) && match.end_offset() > length) // /./
	{
		length = match.end_offset();
		type = CHARACTER;
	}

	self.current_offset += length;
	if (length == 0)
	{
		self.log_here(string::tformat(`Unexpected character '%s'!`, rest[0:1].tescape(true)));
		self.current_offset += 1;
		return runtime::UNEXPECTED_CHARACTER?;
	}

	self.mode_stack.pop()!!;
	if (self.mode_stack.len() == 0)
	{
		self.log_at({offset, length}, `token caused mode stack to become empty`);
		return runtime::MODE_STACK_CLEARED?;
	}
	self.current = {type, {offset,length}, rest[:length]};
}

fn void? LexerLexer.advance_comment(&self)
{
	usz offset = self.current_offset;
	String rest = self.file_data[offset..];
	usz length;
	bool is_pop;

	if (1 > length && rest.starts_with("\n"))
	{
		length = 1;
		is_pop = true;
	}
	if (try match = regex4.match_in_view(rest, 0, tmem) && match.end_offset() > length) // /.+/
	{
		length = match.end_offset();
		is_pop = false;
	}
	self.current_offset += length;
	if (length == 0)
	{
		self.log_here(string::tformat(`Unexpected character '%s'!`, rest[0:1].tescape(true)));
		self.current_offset += 1;
		return runtime::UNEXPECTED_CHARACTER?;
	}

	if (is_pop)
	{
		self.mode_stack.pop()!!;
		if (self.mode_stack.len() == 0)
		{
			self.log_at({offset, length}, `token caused mode stack to become empty`);
			return runtime::MODE_STACK_CLEARED?;
		}
	}
	return runtime::SINGLE_STEP_DROPPED?;
}
/* REGEXEN */

RuntimeRegex regex0; // /\s+/
RuntimeRegex regex1; // /[a-z][a-zA-Z0-9_]*/
RuntimeRegex regex2; // /[A-Z][A-Z0-9_]*/
RuntimeRegex regex3; // /./
RuntimeRegex regex4; // /.+/

/* INITIALIZATION OF REGEXEN */

fn void init_regexen() @private @init
{
	regex0 = regex::make_runtime_regex(`\s+`,NONE,mem)!!;
	regex1 = regex::make_runtime_regex(`[a-z][a-zA-Z0-9_]*`,NONE,mem)!!;
	regex2 = regex::make_runtime_regex(`[A-Z][A-Z0-9_]*`,NONE,mem)!!;
	regex3 = regex::make_runtime_regex(`.`,NONE,mem)!!;
	regex4 = regex::make_runtime_regex(`.+`,NONE,mem)!!;
}
